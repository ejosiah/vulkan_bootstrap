#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_nonuniform_qualifier : enable

#define USE_PCG 0
#define MIN_BOUNCES 3

#include "ray_tracing_lang.glsl"
#include "random.glsl"
#include "common.glsl"
#include "sampling.glsl"
#include "octahedral.glsl"
#include "util.glsl"
#include "brdf.glsl"

layout(set = 0, binding = 0) uniform accelerationStructure topLevelAs;
layout(set = 0, binding = 1) uniform CameraProperties{
    mat4 viewInverse;
    mat4 projInverse;
} cam;
layout(set = 0, binding = 2, rgba32f) uniform image2D image;
layout(set = 0, binding = 3) uniform sampler2D envMap;

layout(set = 1, binding = 0, std430) buffer MATERIALS{
    Material m[];
} materials[];


layout(binding = 1, set = 1) buffer MATERIAL_ID {
    int i[];
} matIds [];


layout(binding = 2, set = 1) buffer OBJECT_INSTANCE {
    SceneObject sceneObjs[];
};

layout(binding = 0, set = 2) buffer VERTEX_BUFFER {
    Vertex v[];
} vertices[];

layout(binding = 1, set = 2) buffer INDEX_BUFFER {
    int i[];
} indices[];

layout(binding = 2, set = 2) buffer VETEX_OFFSETS {
    VertexOffsets vo[];
} offsets[];

layout(set = 4, binding = 0) uniform sampler2D environmentMap;
layout(set = 4, binding = 1) uniform sampler2D pConditionalVFunc;
layout(set = 4, binding = 2) uniform sampler2D pConditionalVCdf;
layout(set = 4, binding = 3) uniform sampler1D pMarginal;
layout(set = 4, binding = 4) uniform sampler1D pMarginalCdf;

layout(push_constant) uniform SceneConstants {
    uint maxBounces;
    uint frame;
    uint currentSample;
    uint numSamples;
    int numLights;
    int adaptiveSampling;
    float worldRadius;
    float pMarginalIntegral;
    uint mask;
    int diffuseType;
    int specularType;
    int ndfFunc;
    float exposure;
    float skyIntensity;
};

layout(location = 0) rayPayload HitData hitData;

vec3 loadEnvColor(vec3 direction);

void getTriangle(int objId, mat4x3 xform, uint offsetId, uint primitiveId, out Vertex v0, out Vertex v1, out Vertex v2);

Surface getSurfaceData(HitData hitData, vec3 wo);

// Calculates probability of selecting BRDF (specular or diffuse) using the approximate Fresnel term
float getBrdfProbability(vec3 V, vec3 sN, vec3 albedo, float metalness);

vec3 evalIndirectBrdf(Surface surface, int brdfType, vec3 wo, inout RngStateType rngState, out vec3 wi);

void main(){
    uint N =  gl_LaunchSize.x * gl_LaunchSize.y * maxBounces * numSamples;
    RngStateType rngState = initRNG(vec2(gl_LaunchID), vec2(gl_LaunchSize), frame);
    vec2 offset = vec2(rand(rngState), rand(rngState));
    const vec2 pixelCenter = vec2(gl_LaunchID.xy) + offset;

    const vec2 uv = pixelCenter/vec2(gl_LaunchSize.xy);
    vec2 d = uv * 2.0 - 1.0;

    vec3 origin = vec3(cam.viewInverse * vec4(0,0,0,1));
    vec3 target = vec3(cam.projInverse * vec4(d.x, d.y, 1, 1));
    vec3 direction = vec3(cam.viewInverse*vec4(normalize(target.xyz), 0));

    float tmin = 0;
    float tmax = FLT_MAX;


    if(currentSample > 10 && currentSample >= numSamples){
        return;
    }

    vec3 Lo = vec3(0);
    vec3 throughput = vec3(1);
    for(uint bounce = 0; bounce < maxBounces; bounce++){
        traceRay(topLevelAs, gl_RayFlagsOpaque, mask, 0, 0, 0, origin, tmin, direction, tmax, 0);
        if(!hitData.hit){
            Lo = throughput * loadEnvColor(direction);
            break;
        }

        vec3 wo = -direction;
        Surface surface  = getSurfaceData(hitData, wo);
        Lo += surface.emission;

        // direct light contribution


        int brdfType = BRDF_DIFFUSE;
        vec3 brdfWeight = evalIndirectBrdf(surface, brdfType, wo, rngState, direction);
        throughput *= brdfWeight;

        if(isBlack(brdfWeight) ||  bounce >= maxBounces - 1){
            break;
        }

        origin = offsetRay(surface.x, surface.gN);

//        vec3 T, B, N = surface.sN;
//        othonormalBasis(T, B, N);
//        mat3 tbn = mat3(T, B, N);
//
//        vec2 u = randomVec2(rngState);
//        direction = tbn * sampleHemisphere(u);
//        origin = offsetRay(surface.x, surface.gN);
    }

    Lo = 1 - exp(-Lo * exposure);
    Lo = linearToSrgb(Lo);
    float t = 1/float(currentSample + 1);
    vec3 dst = imageLoad(image, ivec2(gl_LaunchID.xy)).rgb;
    Lo = mix(dst, Lo, t);
    
    imageStore(image, ivec2(gl_LaunchID.xy), vec4(Lo, 1));
}


vec3 loadEnvColor(vec3 direction){
    vec2 suv = sampleSphere(direction);
    return texture(envMap, suv).rgb * skyIntensity;
}

Surface getSurfaceData(HitData hitData, vec3 wo){
    Surface surface;
    Vertex v0, v1, v2;
    SceneObject sceneObj = sceneObjs[hitData.instanceId];
    int objId = sceneObj.objId;
    getTriangle(objId, hitData.objToWorld, hitData.vertexOffsetId, hitData.primitiveId, v0, v1, v2);
    float u = 1 - hitData.attribs.x - hitData.attribs.y;
    float v = hitData.attribs.x;
    float w = hitData.attribs.y;

    surface.x = u * v0.position + v * v1.position + w * v2.position;
    surface.sN = normalize(u * v0.normal + v * v1.normal + w * v2.normal);
    vec3 e0 = v1.position - v0.position;
    vec3 e1 = v2.position - v0.position;
    surface.gN = normalize(cross(e0, e1));

    VertexOffsets offset = offsets[objId].vo[hitData.vertexOffsetId];
    int matId = matIds[objId].i[hitData.primitiveId + offset.material];
    Material material = materials[objId].m[matId];
    surface.albedo = material.diffuse;
    surface.emission = material.emission;
    surface.metalness = material.metalness.x;
    surface.roughness = material.roughness;

//    if(hitData.instanceId == 8){
        surface.albedo = checkerboard(surface.x, surface.gN) * surface.albedo;
//    }

    if(dot(surface.gN, wo) < 0){
        surface.gN *= -1;
        surface.sN *= -1;
    }

    return surface;
}

void getTriangle(int objId, mat4x3 xform, uint offsetId, uint primitiveId, out Vertex v0, out Vertex v1, out Vertex v2){
    uint vertexOffsetId = 0;
    VertexOffsets offset = offsets[objId].vo[offsetId];

    ivec3 index = ivec3(
    indices[objId].i[offset.firstIndex + 3 * primitiveId + 0],
    indices[objId].i[offset.firstIndex + 3 * primitiveId + 1],
    indices[objId].i[offset.firstIndex + 3 * primitiveId + 2]
    );

    v0 = vertices[objId].v[index.x + offset.vertexOffset];
    v1 = vertices[objId].v[index.y + offset.vertexOffset];
    v2 = vertices[objId].v[index.z + offset.vertexOffset];

    v0.position = (xform * vec4(v0.position, 1)).xyz;
    v1.position = (xform * vec4(v1.position, 1)).xyz;
    v2.position = (xform * vec4(v2.position, 1)).xyz;

    mat3 nMatrix = inverse(transpose(mat3(xform)));

    v0.normal = nMatrix * v0.normal;
    v1.normal = nMatrix * v1.normal;
    v2.normal = nMatrix * v2.normal;
}

float getBrdfProbability(vec3 V, vec3 sN, vec3 albedo, float metalness) {

    // Evaluate Fresnel term using the shading normal
    // Note: we use the shading normal instead of the microfacet normal (half-vector) for Fresnel term here. That's suboptimal for rough surfaces at grazing angles, but half-vector is yet unknown at this point
    vec3 specularF0 = vec3(luminance(baseColorToSpecularF0(albedo, metalness)));
    float diffuseReflectance = luminance(baseColorToDiffuseReflectance(albedo, metalness));
    float Fresnel = saturate(luminance(evalFresnel(specularF0, shadowedF90(specularF0), max(0.0f, dot(V, sN)))));

    // Approximate relative contribution of BRDFs using the Fresnel term
    float specular = Fresnel;
    float diffuse = diffuseReflectance * (1.0f - Fresnel); //< If diffuse term is weighted by Fresnel, apply it here as well

    // Return probability of selecting specular BRDF over diffuse BRDF
    float p = (specular / max(0.0001f, (specular + diffuse)));

    // Clamp probability to avoid undersampling of less prominent BRDF
    return clamp(p, 0.1f, 0.9f);
}

vec3 evalIndirectBrdf(Surface surface, int brdfType, vec3 wo, inout RngStateType rngState, out vec3 wi){


    BrdfArgs args;
    args.wo = wo;
    args.surfacePoint = surface.x;
    args.surfaceNormal = surface.sN;
    args.surfaceGeomNormal = surface.gN;
    args.surfaceAlbedo = surface.albedo;
    args.surfaceMetalness = surface.metalness;
    args.surfaceRoughness = surface.roughness;
    args.diffuseType = diffuseType;
    args.specularType = specularType;
    args.ndfFunc = ndfFunc;
    args.rngState = rngState;
    args.brdfType = brdfType;

    vec3 sampleWeight = evalIndirectCombinedBRDF(args);

    rngState = args.rngState;
    wi = args.wi;
    return sampleWeight;

}