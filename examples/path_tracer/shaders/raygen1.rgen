#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : enable

#define USE_PCG 0
#define MIN_BOUNCES 3

#include "ray_tracing_lang.glsl"
#include "random.glsl"
#include "common.glsl"
#include "sampling.glsl"
#include "octahedral.glsl"
#include "util.glsl"

layout(set = 0, binding = 0) uniform accelerationStructure topLevelAs;
layout(set = 0, binding = 1) uniform CameraProperties{
    mat4 viewInverse;
    mat4 projInverse;
} cam;
layout(set = 0, binding = 2, rgba32f) uniform image2D image;
layout(set = 0, binding = 3) uniform sampler2D envMap;

layout(set = 4, binding = 0) uniform sampler2D environmentMap;
layout(set = 4, binding = 1) uniform sampler2D pConditionalVFunc;
layout(set = 4, binding = 2) uniform sampler2D pConditionalVCdf;
layout(set = 4, binding = 3) uniform sampler1D pMarginal;
layout(set = 4, binding = 4) uniform sampler1D pMarginalCdf;

layout(push_constant) uniform SceneConstants {
    uint maxBounces;
    uint frame;
    uint currentSample;
    uint numSamples;
    int numLights;
    int adaptiveSampling;
    float worldRadius;
    float pMarginalIntegral;
    uint mask;
    int diffuseType;
    int specularType;
    int ndfFunc;
    float exposure;
    float skyIntensity;
};

layout(location = 0) rayPayload RayTraceData rtData;

vec3 loadEnvColor(vec3 direction);

void main(){
    RngStateType rngState = initRNG(vec2(gl_LaunchID), vec2(gl_LaunchSize), frame);
    vec2 offset = vec2(rand(rngState), rand(rngState));
    const vec2 pixelCenter = vec2(gl_LaunchID.xy) + offset;

    const vec2 uv = pixelCenter/vec2(gl_LaunchSize.xy);
    vec2 d = uv * 2.0 - 1.0;

    vec3 origin = vec3(cam.viewInverse * vec4(0,0,0,1));
    vec3 target = vec3(cam.projInverse * vec4(d.x, d.y, 1, 1));
    vec3 direction = vec3(cam.viewInverse*vec4(normalize(target.xyz), 0));

    float tmin = 0;
    float tmax = FLT_MAX;

    init(rtData, -direction, rngState);

    vec3 color = vec3(0);
    traceRay(topLevelAs, gl_RayFlagsOpaque, mask, 0, 0, 0, origin, tmin, direction, tmax, 0);

    if (!rtData.hit){
        color = loadEnvColor(direction);
    } else {
        vec3 L = normalize(-direction);
        color = rtData.brdfWeight * dot(rtData.sn, L);
    }


    imageStore(image, ivec2(gl_LaunchID.xy), vec4(color, 1));
}


vec3 loadEnvColor(vec3 direction){
    vec2 suv = sampleSphere(direction);
    return texture(envMap, suv).rgb;
}