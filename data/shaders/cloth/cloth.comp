#version 460 core

#define PI 3.1415926535897932384626433832795
#define TWO_PI 6.283185307179586476925286766559
#define PI_OVER_4 0.78539816339744830961566084581988

layout(local_size_x = 10, local_size_y = 10) in;

struct Particle{
    vec4 position;
    vec4 color;
    vec3 normal;
    vec3 tangent;
    vec3 bitangent;
    vec2 uv;
};

layout(set = 0, binding = 0) buffer POINT_MASSES_IN{
    Particle particleIn[];
};

layout(set = 1, binding = 0) buffer POINT_MASS_OUT{
    Particle particleOut[];
};

layout(push_constant) uniform SIM_CONSTANTS {
    vec2 inv_cloth_size;
    float timeStep;
    float mass;
    float ksStruct;
    float ksShear;
    float ksBend;
    float kdStruct;
    float kdShear;
    float kdBend;
    float kd;
    float elapsedTime;
};

layout(constant_id = 0) const float gravityY = -9.81f;

vec3 gravity = vec3(0, gravityY, 0);
int width = int(gl_WorkGroupSize.x * gl_NumWorkGroups.x);
int height = int(gl_WorkGroupSize.y * gl_NumWorkGroups.y);
int numPoints = height * width;
int id = int(gl_GlobalInvocationID.y * width + gl_GlobalInvocationID.x);
//int id = int(gl_LocalInvocationIndex);

ivec2 neighbourIndices[12] = {
    ivec2(0, 1), ivec2(1, 0), ivec2(0, -1), ivec2(-1, 0),  // structural neigbhours
    ivec2(-1, 1), ivec2(1, 1), ivec2(-1, -1), ivec2(1, -1),  // shear neigbhours
    ivec2(0, 2), ivec2(0, -2), ivec2(-2, 0), ivec2(2, 0)    // bend neigbhours
};

bool neighbour(int i, out vec3 pos, out vec3 prev_pos, out float ks, out float kd, out float rest_length){
    ivec2 coord = neighbourIndices[i];
    ivec2 index =  coord + ivec2(gl_GlobalInvocationID.xy);
    if(index.x < 0 || index.x >= width || index.y < 0 || index.y >= height){
        return false;
    }
    int nid = index.y * width + index.x;

    pos = particleIn[nid].position.xyz;
    prev_pos = particleOut[nid].position.xyz;

    rest_length = length(coord * inv_cloth_size);
    if(i < 4){
        ks = ksStruct;
        kd = kdStruct;
    }else if(i < 8){
        ks = ksShear;
        kd = kdShear;
    }else if(i < 12){
        ks = ksBend;
        kd = kdBend;
    }

    return true;
}

void main(){
//    float dt = 0.00083;
    float dt = timeStep;
    float inv_dt = 1/dt;
    vec3 pos = particleIn[id].position.xyz;
    vec3 prev_pos = particleOut[id].position.xyz;
    vec3 velocity = (pos - prev_pos) * inv_dt;

    float t = elapsedTime;
    float f = 10 * TWO_PI;
    vec3 wind = vec3( 10 * cos(f * t), 0, 0);
    vec3 force = mass * gravity + kd * (wind-velocity);

    for(int i = 0; i < 12; i++){
        vec3 nPos;
        vec3 nPrev_pos;
        float ks;
        float kd;
        float l;

        if(!neighbour(i, nPos, nPrev_pos, ks, kd, l)){
            continue;
        }

        vec3 d = nPos - pos;
        vec3 d_norm = normalize(d);
        float dist = length(d);
        vec3 nVelocity = (nPos - nPrev_pos) * inv_dt;

        vec3 f = d_norm * (ks * (dist - l) + kd * dot(nVelocity - velocity, d_norm));

        force += f;
    }

    float inv_mass = 1.0f/mass;
    if(id == (numPoints - width) || id == (numPoints - 1)){
        inv_mass = 0;
    }

    vec3 a = force * inv_mass;

    vec3 p = 2 * pos - prev_pos + a * dt * dt;

    if(p.y < 0) p.y = 0;


    particleIn[id].position.xyz = pos;
    particleOut[id].position.xyz = p;
}