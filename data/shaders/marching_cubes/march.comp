#version 460 core
#extension GL_EXT_scalar_block_layout : enable

#define NUM_VERTICES 8
#define NUM_EDGES 12
#define MAX_TRIANGLE_VERTICES 16


struct Vertex{
    vec3 position;
    vec3 normal;
};

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

layout(set = 0, binding = 0) uniform sampler3D sdf;

layout(set = 0, binding = 1, scalar) buffer ATOMIC_COUNTERS{
    uint vertex_count;
    uint next_vertex_id;
};

layout(set = 0, binding = 2, scalar) buffer EDGE_TABLE{
    uint edgeTable[256];
};
layout(set = 0, binding = 3, scalar) buffer TRI_TABLE{
    int triTable[4096];
};

layout(set = 0, binding = 4) buffer VERTICES{
    Vertex vertices[];
};

layout(push_constant) uniform Constants{
    layout(offset = 192)
    float isoLevel;
    int pass;
};

const vec3 CubeVertices[NUM_VERTICES] = {
    vec3(-0.5, -0.5, -0.5),
    vec3(0.5, -0.5, -0.5),
    vec3(0.5, -0.5, 0.5),
    vec3(-0.5, -0.5, 0.5),
    vec3(-0.5, 0.5, -0.5),
    vec3(0.5, 0.5, -0.5),
    vec3(0.5, 0.5, 0.5),
    vec3(-0.5, 0.5, 0.5),
};

const ivec2 cubeEdges[NUM_EDGES] = {
    ivec2(0, 1), ivec2(1, 2), ivec2(2, 3), ivec2(3, 0),
    ivec2(4, 5), ivec2(5, 6), ivec2(6, 7), ivec2(7, 4),
    ivec2(0, 4), ivec2(1, 5), ivec2(2, 6), ivec2(3, 7)
};

vec3 vertexList[NUM_EDGES];
float isoValues[NUM_VERTICES];
Vertex triangles[MAX_TRIANGLE_VERTICES];

vec3 getVertex(vec3 center, vec3 gridSize, int edgeIndex){
    ivec2 edge = cubeEdges[edgeIndex];
    vec3 p0 = center + CubeVertices[edge[0]] * gridSize;
    vec3 p1 = center + CubeVertices[edge[1]] * gridSize;

    float isoVal0 = isoValues[edge[0]];
    float isoVal1 = isoValues[edge[1]];
    float t = (isoLevel - isoVal0)/(isoVal1 - isoVal0);

    return mix(p0, p1, t);
}

float getIsoValue(vec3 center, vec3 gridSize, int index){
    vec3 p = center + CubeVertices[index] * gridSize;

    vec3 coord = 0.5 * p + 0.5;
    return texture(sdf, coord).r;

}

void main(){
    uvec3 size = gl_WorkGroupSize * gl_NumWorkGroups;
    vec3 invSize = vec3(1)/vec3(gl_WorkGroupSize * gl_NumWorkGroups);
    vec3 gridSize = 2.0 * invSize;
    vec3 p = 2.0 * vec3(gl_GlobalInvocationID) * invSize - 1.0; // [0, 1] -> [-1, 1]
    vec3 cellCenter = p + gridSize * 0.5;
    int config = 0;

    for(int i = 0; i < 8; i++){
        isoValues[i] = getIsoValue(cellCenter, gridSize, i);
        if(isoValues[i] < isoLevel){
            config |= (1 << i);
        }
    }

    if(edgeTable[config] == 0) return;

    for(int edge = 0; edge < NUM_EDGES; edge++){
        if((edgeTable[config] & (1 << edge)) != 0){
            vertexList[edge] = getVertex(cellCenter, gridSize, edge);
        }
    }
    
    int numVertices = 0;
    for(int i = config * MAX_TRIANGLE_VERTICES; triTable[i] != -1; i+= 3){
        vec3 p0 = vertexList[triTable[i]];
        vec3 p1 = vertexList[triTable[i + 1]];
        vec3 p2 = vertexList[triTable[i + 2]];

        vec3 a = p1 - p0;
        vec3 b = p2 - p0;
        vec3 normal = normalize(cross(a, b));

        triangles[numVertices++] = Vertex(p0, normal);
        triangles[numVertices++] = Vertex(p1, normal);
        triangles[numVertices++] = Vertex(p2, normal);
    }

    atomicAdd(vertex_count, numVertices);

    if(pass == 0) return;

    uint offset = atomicAdd(next_vertex_id, numVertices);
    for(int i = 0; i < numVertices; i++){
        vertices[i + offset] = triangles[i];
    }

}