#version 460 core

#define DATA_ITERMS_PER_WORKGROUP 8192
#define STUFF 0
#define SHARED_STORAGE_SIZE (2048)
#define BANKS 32
#define LOG_BANKS 5
#define CONFLICT_FREE_OFFSET(n) (((n) >> LOG_BANKS))
#define NUM_SMEM_ELEMENTS SHARED_STORAGE_SIZE + CONFLICT_FREE_OFFSET(SHARED_STORAGE_SIZE)
#define CONFLICT_FREE_ID(n) (n) + CONFLICT_FREE_OFFSET(n)
#define GET(DATA, INDEX)

layout(local_size_x = 1024) in;

layout(set = 0, binding = 0) buffer DATA {
  float g_data[];
};

layout(set = 1, binding = 0) buffer SUMS {
  float g_sums[];
};

shared float data[NUM_SMEM_ELEMENTS];

void scan(inout vec4 v, out float sum);

void main(){
  int thid  = int(gl_LocalInvocationIndex);
  int gthid = int(gl_GlobalInvocationID.x);
  int gthid2 = int(gthid + SHARED_STORAGE_SIZE/2);
  int gOffset = int(gl_WorkGroupID.x * DATA_ITERMS_PER_WORKGROUP/2);
  int n = SHARED_STORAGE_SIZE;

  // FIXME out of bounds data access
  // sequencial memory access
  vec4 temp0 = vec4(g_data[4 * gthid + 0 + gOffset], g_data[4 * gthid + 1 + gOffset], g_data[4 * gthid + 2 + gOffset], g_data[4 * gthid + 3 + gOffset]);
  vec4 temp1 = vec4(g_data[4 * gthid2 + 0 + gOffset], g_data[4 * gthid2 + 1 + gOffset], g_data[4 * gthid2 + 2 + gOffset], g_data[4 * gthid2 + 3 + gOffset]);

  float sum = 0;
  int ai = CONFLICT_FREE_ID(thid);
  scan(temp0, sum);
  data[ai] = sum;

  int bi = CONFLICT_FREE_ID(thid + SHARED_STORAGE_SIZE/2);
  scan(temp1, sum);
  data[bi] = sum;

  int offset = 1;
  for(int d = (n >> 1); d > 0; d >>= 1){
    barrier();
    if(thid < d){
      int ai = CONFLICT_FREE_ID(offset * (2 * thid + 1) - 1);
      int bi = CONFLICT_FREE_ID(offset * (2 * thid + 2) - 1);

      data[bi] += data[ai];
    }
    offset *= 2;
  }

  if(thid == 0){
    int last = CONFLICT_FREE_ID(n - 1);
    float temp = data[last];
    data[last] = 0;
    g_sums[gl_WorkGroupID.x] = temp;
  }

  for(int d = 1; d < n; d *= 2){
    offset >>= 1;
    barrier();
    if(thid < d){
      int ai = CONFLICT_FREE_ID(offset * (2 * thid + 1) - 1);
      int bi = CONFLICT_FREE_ID(offset * (2 * thid + 2) - 1);

      float temp = data[bi];
      data[bi] = temp + data[ai];
      data[ai] = temp;
    }
  }

  barrier();

  float sum0 = data[ai];
  float sum1 = data[bi];

  temp0 += vec4(sum0);
  temp1 += vec4(sum1);

  // FIXME out of bounds data access
  g_data[4 * gthid + 0 + gOffset] = temp0.x;
  g_data[4 * gthid + 1 + gOffset] = temp0.y;
  g_data[4 * gthid + 2 + gOffset] = temp0.z;
  g_data[4 * gthid + 3 + gOffset] = temp0.w;

  // FIXME out of bounds data access
  g_data[4 * gthid2 + 0 + gOffset] = temp1.x;
  g_data[4 * gthid2 + 1 + gOffset] = temp1.y;
  g_data[4 * gthid2 + 2 + gOffset] = temp1.z;
  g_data[4 * gthid2 + 3 + gOffset] = temp1.w;
}

void scan(inout vec4 v, out float sum){
  sum = 0;
  float temp = v.x;
  v.x = sum;
  sum += temp;

  temp = v.y;
  v.y = sum;
  sum += temp;

  temp = v.z;
  v.z = sum;
  sum += temp;

  temp = v.w;
  v.w = sum;
  sum += temp;
}