#version 460 core
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable

#include "../hash.glsl"

struct Particle{
    vec4 position;
    vec4 color;
    vec3 velocity;
    float invMass;
};

layout(local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;

layout(push_constant) uniform Constants {
//    layout(offset = 224)
    vec3 resolution;
    int pass;
    vec3 gridSpacing;
    int numParticles;
};

layout(set = 0, binding = 0) buffer POINTS {
    Particle points[];
};

layout(set = 1, binding = 0, scalar) buffer BUCKETS {
    int buckets[];
};

layout(set = 1, binding = 1, scalar) buffer BUCKET_SIZES {
    int bucketSize[];
};

layout(set = 1, binding = 2, scalar) buffer NEXT_BUCKET_INDEX {
    int nextBucketIndex[];
};

vec3 wrap(vec3 bucketIndex){
    return bucketIndex + (1 - step(0, bucketIndex)) * resolution;
}

int toHashKey(vec3 bucketIndex){
    return int((bucketIndex.z * resolution.y + bucketIndex.y) * resolution.x + bucketIndex.x);
}

int getHashKey(vec3 point){
    vec3 bucketIndex = floor(point/gridSpacing);
    bucketIndex = wrap(mod(bucketIndex, resolution));
    return toHashKey(bucketIndex);
}

int getOffset(int key){
    int offset = 0;
    for(int i = key - 1; i >= 0; i--){
        offset += bucketSize[i];
    };
    return offset;
}

void main(){
    int id = int(gl_GlobalInvocationID.x);

    if(id >= numParticles) return;

    vec3 point = points[id].position.xyz;
    int key = getHashKey(point);
    if(pass == 0){
        atomicAdd(bucketSize[key], 1);  // TODO use different buffer for this
        return;
    }
    int offset = getOffset(key);    // TODO maybe run prefix scan if grid is big
    int index = offset + atomicAdd(nextBucketIndex[key], 1);
    buckets[index] = id;
}