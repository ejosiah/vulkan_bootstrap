#version 460 core
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable

#include "common.glsl"
#include "../hash.glsl"
#include "point_hash_grid.glsl"

layout(local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;

layout(push_constant) uniform Constants {
    layout(offset = 0)
    vec3 resolution;
    float gridSpacing;
    int pass;
    int numParticles;
};

layout(set = 0, binding = 0) buffer POINTS {
    vec4 points[];
};

layout(set = 1, binding = 0, scalar) buffer BUCKETS {
    int buckets[];
};

layout(set = 1, binding = 1, scalar) buffer NEXT_BUCKET_INDEX {
    int nextBucketIndex[];
};

layout(set = 2, binding = 0, scalar) buffer BUCKET_SIZES {
    int bucketSize[];
};

layout(set = 2, binding = 1, scalar) buffer BUCKET_SIZE_OFFSET {
    int bucketSizeOffset[];

};
layout(set = 3, binding = 0, scalar) buffer NEIGHBOUR_LIST{
    int neighbourList[];
};

layout(set = 3, binding = 1, scalar) buffer ATOMIC_COUNTER{
    int counter[];
};

layout(set = 4, binding = 0, scalar) buffer NEIGHBOUR_LIST_SIZES{
    int neighbourListSizes[];
};

void main(){
    uvec3 id = gl_GlobalInvocationID;
    uvec3 size = gl_WorkGroupSize * gl_NumWorkGroups;
    int gIndex = int((id.z * size.y + id.y) * size.x + id.x);
    int index = int(gl_LocalInvocationID.x);
    int neighbourId = int(gl_GlobalInvocationID.y);

    if(index >= numParticles) return;

    vec3 origin = points[index].xyz;

    int nearByKeys[8];
    getNearByKeys(origin, gridSpacing, resolution, nearByKeys);

    float radius = gridSpacing * 0.5;
    float radiusSqr = radius * radius;
    if(pass == 0){
        int neighbourListSize = 0;
        int bucketIndex = nearByKeys[neighbourId];
        if(bucketIndex < 0) return;

        int numPointsInBucket = bucketSize[bucketIndex];
        if(numPointsInBucket <= 0) return;

        int bucketOffset = bucketSizeOffset[bucketIndex];
        for(int j = int(gl_GlobalInvocationID.z); j < numPointsInBucket; j += int(size.z)){
            int pointIndex = buckets[j + bucketOffset];
            vec3 point = points[pointIndex].xyz;
            vec3 d = point - origin;
            if(dot(d, d) <= radiusSqr){
                atomicAdd(neighbourListSizes[index], 1);
            }
        }
        return;
    }

    int invocationOffset = 0;
    int bucketIndex = nearByKeys[neighbourId];
    if(bucketIndex < 0) return;

    int numPointsInBucket = bucketSize[bucketIndex];

    int bucketOffset = bucketSizeOffset[bucketIndex];

    int offset = neighbourListSizes[index];
    for(int j = int(gl_GlobalInvocationID.z); j < numPointsInBucket; j += int(size.z)){
        int pointIndex = buckets[j + bucketOffset];
        vec3 point = points[pointIndex].xyz;
        vec3 d = point - origin;
        if(dot(d, d) <= radiusSqr){
            invocationOffset = atomicAdd(counter[index], 1);
            int listIndex = invocationOffset + offset;
            neighbourList[listIndex]  = pointIndex;
        }
    }
}