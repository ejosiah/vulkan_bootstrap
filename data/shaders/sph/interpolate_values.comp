#version 460

#extension GL_EXT_scalar_block_layout : enable

#define DENSITY  (1 << 0)
#define PRESSURE (1 << 1)
#define COLOR    (1 << 2)

#include "common.glsl"
#include "std_kernel.glsl"

layout(local_size_x = 1024) in;

layout(set = 0, binding = 0) buffer Points{
    vec4 pointsIn[];
};

layout(set = 0, binding = 1, scalar) buffer PData{
    ParticleData dataIn[];
};

layout(set = 1, binding = 0, scalar) buffer NEIGHBOUR_LIST{
    int neighbourList[];
};

layout(set = 2, binding = 0, scalar) buffer NEIGHBOUR_LIST_SIZES{
    int neighbourListSizes[];
};

layout(set = 3, binding = 0, scalar) buffer NEIGHBOUR_LIST_SIZE_OFFSET{
    int neighbourListSizeOffsets[];
};

layout(push_constant) uniform Constants{
    layout(offset = 0)
    int numParticles;
    float radius;
    float invMass;
    int fieldToUpdate;
};

void interpolateDensity();
void interpolateColor();
void interpolatePressure();

void main(){
    int index = int(gl_GlobalInvocationID.x);

    if(index >= numParticles) return;

    vec3 origin = pointsIn[index].xyz;
    int offset = neighbourListSizeOffsets[index];
    int size = neighbourListSizes[index];
    float mass = 1/invMass;
    float h = radius;

    if((fieldToUpdate & DENSITY) == DENSITY){
        float density = 0;
        for(int i = 0; i < size; i++){
            int neighbourIndex = neighbourList[i + offset];
            vec3 neighbourPoint = pointsIn[neighbourIndex].xyz;
            density += kernel(h, distance(origin, neighbourPoint));
        }
        density *= mass;
        dataIn[index].density = density;
    }

    if((fieldToUpdate & COLOR) == COLOR){
        vec3 color = vec3(0);
        for(int i = 0; i < size; i++){
            int neighbourIndex = neighbourList[i + offset];
            vec3 neighbourPoint = pointsIn[neighbourIndex].xyz;
            color += kernel(h, distance(origin, neighbourPoint));
        }
        color *= mass;
        dataIn[index].color.rgb = color;
    }
}